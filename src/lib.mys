from fiber import Fiber
from fiber import current
from fiber import resume
from fiber import suspend
from .client import Object as ClientObject
from .marshaling import marshal
from .marshaling import unmarshal
from .message import HeaderFields
from .message import Type as MessageType
from .server import Object as ServerObject
from .types import Array
from .types import Byte
from .types import ObjectPath
from .types import Signature
from .types import String
from .types import Struct
from .types import Type
from .types import Uint32

_PROTOCOL_VERSION: u8 = 1

@trait
class SignalHandler:
    pass

class Handler:
    pass

@trait
class Bus:
    pass

class _Completion:
    fiber: Fiber
    header: [Type]
    data: [Type]

class _MessageReader(Fiber):

    def run(self):
        while True:
            serial, message_type, body, header_fields = self._read_message()

            match message_type:
                case MessageType.MethodCall:
                    self._handle_method_call()
                case MessageType.MethodReturn:
                    self._handle_method_return(serial, body, header_fields)
                case MessageType.Error:
                    self._handle_error()
                case MessageType.Signal:
                    self._handle_signal()

    def _read(self, size: u32) -> bytes:
        raise NotImplementedError()

    def _read_message(self) -> (u32, MessageType, bytes, [Type]):
        data = self._read(16)

        if data[3] != _PROTOCOL_VERSION:
            raise NotImplementedError()

        big_endian = (data[0] == u8(i32('B')))

        if big_endian:
            header_fields_size = ((u32(data[13]) << 24)
                                  | (u32(data[14]) << 16)
                                  | (u32(data[15]) << 8)
                                  | (u32(data[16]) << 0))
        else:
            header_fields_size = ((u32(data[13]) << 0)
                                  | (u32(data[14]) << 8)
                                  | (u32(data[15]) << 16)
                                  | (u32(data[16]) << 24))

        header_fields_size += 7
        header_fields_size &= ~0x7

        data += self._read(header_fields_size)
        header = unmarshal("yyyyuua(yv)", data, big_endian)
        body = self._read(header[4].to_uint32())

        return (header[5].to_uint32(),
                MessageType(header[1].to_byte()),
                body,
                header[6].to_array())

    def _handle_method_call(self):
        raise NotImplementedError()

    def _handle_method_return(self,
                              serial: u32,
                              body: bytes,
                              header_fields: [Type]):
        raise NotImplementedError()

    def _handle_error(self):
        raise NotImplementedError()

    def _handle_signal(self):
        raise NotImplementedError()

def _build_header(serial: u32,
                  message_type: MessageType,
                  body: bytes,
                  header_fields: [Type]) -> [Type]:
    return [
        Byte(u8(i32('B'))),
        Byte(u8(message_type)),
        Byte(0),
        Byte(_PROTOCOL_VERSION),
        Uint32(u32(len(body))),
        Uint32(serial),
        Array(header_fields)
    ]

class SessionBus(Bus):
    _handler: Handler
    _serial: u32
    _completions: {u32: _Completion}

    def __init__(self, handler: Handler = None):
        self._handler = handler
        self._serial = 0
        self._completions = {}

    def start(self):
        """Connect to the bus.

        """

    def stop(self):
        """Disconnect from the bus once all ongoing calls have completed.

        """

    def join(self):
        """Wait for the bus to be stopped.

        """

    def add_object_client(self, object: ClientObject):
        """Add given client object.

        """

    def add_object_server(self, object: ServerObject):
        """Add given server object.

        """

    def add_signal_handler(self, handler: SignalHandler):
        pass

    def call(self,
             destination: string,
             object_path: string,
             interface: string,
             method: string,
             signature: string,
             arguments: [Type]) -> [Type]:
        """Call given method on given object.

        """

        serial = self._next_serial()
        body = marshal(arguments)
        header = _build_header(
            serial,
            MessageType.MethodCall,
            body,
            [
                Struct([Byte(u8(HeaderFields.Path)), ObjectPath(object_path)]),
                Struct([Byte(u8(HeaderFields.Interface)), String(interface)]),
                Struct([Byte(u8(HeaderFields.Destination)), String(destination)]),
                Struct([Byte(u8(HeaderFields.Member)), String(method)]),
                Struct([Byte(u8(HeaderFields.Signature)), Signature(signature)])
            ])
        message = marshal(header, align=8)
        message += body

        completion = _Completion(current(), None, None)
        self._completions[serial] = completion
        self._write(message)
        suspend()

        return completion.data

    def emit(self,
             object_path: string,
             interface: string,
             signal: string,
             signature: string,
             arguments: [Type]):
        """Emit given signal from given object.

        """

        body = marshal(arguments)
        header = _build_header(
            self._next_serial(),
            MessageType.Signal,
            body,
            [
                Struct([Byte(u8(HeaderFields.Path)), ObjectPath(object_path)]),
                Struct([Byte(u8(HeaderFields.Interface)), String(interface)]),
                Struct([Byte(u8(HeaderFields.Member)), String(signal)]),
                Struct([Byte(u8(HeaderFields.Signature)), Signature(signature)])
            ])
        message = marshal(header, align=8)
        message += body

        self._write(message)

    def _next_serial(self) -> u32:
        self._serial += 1

        if self._serial == 0:
            self._serial = 1

        return self._serial

    def _write(self, message: bytes):
        pass
