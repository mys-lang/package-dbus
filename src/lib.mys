from fiber import Fiber
from fiber import current
from fiber import resume
from fiber import suspend
from .client import Object as ClientObject
from .marshaling import marshal
from .message import HeaderFields
from .message import Type as MessageType
from .server import Object as ServerObject
from .types import Array
from .types import Byte
from .types import ObjectPath
from .types import Signature
from .types import String
from .types import Struct
from .types import Type
from .types import Uint32

_PROTOCOL_VERSION: u8 = 1

@trait
class SignalHandler:
    pass

class Handler:
    pass

@trait
class Bus:
    pass

class Completion:
    fiber: Fiber
    header: [Type]
    data: [Type]

def _build_header(serial: u32,
                  message_type: MessageType,
                  body: bytes,
                  header_fields: [Type]) -> [Type]:
    return [
        Byte(u8(i32('B'))),
        Byte(u8(message_type)),
        Byte(0),
        Byte(_PROTOCOL_VERSION),
        Uint32(u32(len(body))),
        Uint32(serial),
        Array(header_fields)
    ]

class SessionBus(Bus):
    _handler: Handler
    _serial: u32
    _completions: {u32: Completion}

    def __init__(self, handler: Handler = None):
        self._handler = handler
        self._serial = 0
        self._completions = {}

    def start(self):
        """Connect to the bus.

        """

    def stop(self):
        """Disconnect from the bus once all ongoing calls have completed.

        """

    def join(self):
        """Wait for the bus to be stopped.

        """

    def add_object_client(self, object: ClientObject):
        """Add given client object.

        """

    def add_object_server(self, object: ServerObject):
        """Add given server object.

        """

    def add_signal_handler(self, handler: SignalHandler):
        pass

    def call(self,
             destination: string,
             object_path: string,
             interface: string,
             method: string,
             signature: string,
             arguments: [Type]) -> [Type]:
        """Call given method on given object.

        """

        serial = self._next_serial()
        body = marshal(arguments)
        header = _build_header(
            serial,
            MessageType.MethodCall,
            body,
            [
                Struct([Byte(u8(HeaderFields.Path)), ObjectPath(object_path)]),
                Struct([Byte(u8(HeaderFields.Interface)), String(interface)]),
                Struct([Byte(u8(HeaderFields.Destination)), String(destination)]),
                Struct([Byte(u8(HeaderFields.Member)), String(method)]),
                Struct([Byte(u8(HeaderFields.Signature)), Signature(signature)])
            ])
        message = marshal(header, align=8)
        message += body

        completion = Completion(current(), None, None)
        self._completions[serial] = completion
        self._write(message)
        suspend()

        return completion.data

    def emit(self,
             object_path: string,
             interface: string,
             signal: string,
             signature: string,
             arguments: [Type]):
        """Emit given signal from given object.

        """

        body = marshal(arguments)
        header = _build_header(
            self._next_serial(),
            MessageType.Signal,
            body,
            [
                Struct([Byte(u8(HeaderFields.Path)), ObjectPath(object_path)]),
                Struct([Byte(u8(HeaderFields.Interface)), String(interface)]),
                Struct([Byte(u8(HeaderFields.Member)), String(signal)]),
                Struct([Byte(u8(HeaderFields.Signature)), Signature(signature)])
            ])
        message = marshal(header, align=8)
        message += body

        self._write(message)

    def _next_serial(self) -> u32:
        self._serial += 1

        if self._serial == 0:
            self._serial = 1

        return self._serial

    def _write(self, message: bytes):
        pass
